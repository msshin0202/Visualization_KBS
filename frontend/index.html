<!DOCTYPE html>
<meta charset="utf-8">
<title>Force-Directed Graph</title>
<style>

    .node {
        cursor: pointer;
        stroke: #3182bd;
        stroke-width: 1.5px;
    }

    .link {
        fill: none;
        stroke: black;
        stroke-width: 1px;
    }

</style>
<body>
<script src="./d3.js"></script>
<script>

    var width = 960,
        height = 500,
        root;

    var force = d3.layout.force()
        .size([width, height])
        .linkDistance(100)
        .charge(-300)
        .on("tick", tick);

    var svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height);

    var link = svg.selectAll(".link"),
        node = svg.selectAll(".node");


    svg.append("defs").append("marker")
        .attr("id", "arrow")
        .attr("viewBox", "0 -5 10 10")
        .attr("refX", 15)
        .attr("refY", -1.5)
        .attr("markerWidth", 6)
        .attr("markerHeight", 10)
        .attr("orient", "auto")
        .append("path")
        .attr("d", "M0,-5L10,0L0,5")
        .style("stroke", "black");



    d3.json("readme2.json", function (error, json) {
        if (error) throw error;

        root = json;
        update()
    });

    function update() {

        var nodes = root,
            links = flatten(root);
        // Restart the force layout.

        getSize(root);
        force
            .nodes(nodes)
            .links(links)
            .start();

        console.log(root);

        // Update the links…
        link = link.data(links);

        // Exit any old links.
        link.exit().remove();

        // Enter any new links.
        link.enter().insert("path", ".node")
            .attr("class", "link")
            .attr("marker-end", "url(#arrow)")
            .style("stroke-width", "2px");
        // .attr("x1", function(d) { return d.source.x; })
        // .attr("y1", function(d) { return d.source.y; })
        // .attr("x2", function(d) { return d.target.x; })
        // .attr("y2", function(d) { return d.target.y; });

        // Update the nodes…
        node = node.data(nodes).style("fill", color);

        // Exit any old nodes.
        node.exit().remove();

        // Enter any new nodes.
        node.enter().append("circle")
            .attr("class", "node")
            .attr("cx", function (d) {
                return d.x;
            })
            .attr("cy", function (d) {
                return d.y;
            })
            .attr("r", function (d) {
                return d.size != 0 ? d.size * 3 : 2;
            })
            .style("fill", color)
            .on("click", click)
            .call(force.drag);

    }

    function tick() {
        link.attr("d", linkArc);
        link.attr("x1", function (d) {
            return d.source.x;
        })
            .attr("y1", function (d) {
                return d.source.y;
            })
            .attr("x2", function (d) {
                return d.target.x;
            })
            .attr("y2", function (d) {
                return d.target.y;
            });

        node.attr("cx", function (d) {
            return d.x;
        })
            .attr("cy", function (d) {
                return d.y;
            });
    }
    function linkArc(d) {
        var dx = d.target.x - d.source.x,
            dy = d.target.y - d.source.y,
            dr = Math.sqrt(dx * dx + dy * dy);
        return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
    }
    // Color leaf nodes orange, and packages white or blue.
    function color(d) {
        return d._children ? "#3182bd" : d.children ? "#c6dbef" : "#fd8d3c";
    }

    // Toggle children on click.
    function click(d) {
        if (!d3.event.defaultPrevented) {
            if (d.children) {
                d._children = d.children;
                d.children = null;
            } else {
                d.children = d._children;
                d._children = null;
            }
            update();
        }
    }

    function getSize(root){
        var nodeMap = {};

        for(let i = 0; i < root.length; i++){
            nodeMap[root[i]["className"]] = root[i];
        }

        for(let i = 0; i < root.length; i++){
            if (root[i].dependency) {
                for (let j = 0; j < root[i].dependency.length; j++) {
                    let className = root[i].dependency[j];
                    nodeMap[className]["size"]++;
                }
            }
        }
    }

    function flatten(root) {
        var nodeMap = {};
        var links = [];

        for (let i = 0; i < root.length; i++) {
            nodeMap[root[i]["className"]] = i;
            root[i]["size"] = 0;
        }

        for (let i = 0; i < root.length; i++) {
            if (root[i].dependency) {
                for (let j = 0; j < root[i].dependency.length; j++) {
                    let link = {source: i, target: nodeMap[root[i].dependency[j]]};
                    links.push(link);
                }
            }
        }
        return links;
    }

    // Returns a list of all nodes under the root.
    // function flatten(root) {
    //     var nodes = [], i = 0;
    //
    //     function recurse(node) {
    //         if (node.children) node.children.forEach(recurse);
    //         if (!node.id) node.id = ++i;
    //         nodes.push(node);
    //     }
    //
    //     recurse(root);
    //     return nodes;
    // }

</script>